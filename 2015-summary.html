<!DOCTYPE html>
<html>
<head>
<title>2015总结</title>
<meta charset='utf8'>
<meta http-equiv="X-UA-Compatible" content="chrome=1">

<link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen" />
<link rel="stylesheet" type="text/css" href="stylesheets/pygment_trac.css" media="screen" />
<link href="images/favicon.ico" rel="shortcut icon" type="image/x-icon">
</head>
<body>

<header>
    <div class="container">
        <h1>2015总结</h1>
    </div>
</header>

<div class="container">
    <section id="main_content">
    <p class="idt">本年度的工作包括了迷你西游和RTS项目开发，简单概括一下。</p>
    <p class="idt">迷你方面依然占据最大的开发工期，包括制作、维护，优化还有客户端方面的工作。</p>
    <p class="idt">（1）合服</p>
    <p class="idt">玩法方面，只是设计上复用掠夺和灵穴，实际代码上要重新写，又是跨服，工作量不少。结果后面基本是采用手工强合，被玩家一直在论坛吐槽，吃力不讨好。合服这种事情，只需明确规则，相对公平即可，一切从简。</p>
    <p class="idt">数据方面，是个大坑，需要了解各个系统和玩法的数据结构，并且要决定哪些必须合，哪些可以去掉，去掉是否有问题等等。这个过程其实很容易出错，而且会把一些隐藏的问题给暴露出来。比如摇钱树有个中层数据，合服后key超65000，load不进来，只能被动的关服再处理。有些中层文件过大，原来的合服工具刚好又写得不好，导致合数据时间超长等。还有些集中式的玩法，比如世界boss、领土争夺，合服后机器变少，单台机器运算负担增加，造成服务器卡，体验很差等等。后面做了很多优化、维护的工作，都是因为类似上面这些合数据合出问题，需要填坑。</p>
    <p class="idt">（2）大乱斗</p>
    <p class="idt">这是我觉得比较好玩的玩法，做完之后我自己每天都在玩，很考验策略和技术。可惜只用在了春节活动中，后面周年庆也曾经拿出来改改再用，但后面就没有再用了。我认为像这种复杂的玩法，应该做成常规玩法。可以不用开得那么频繁，比如一两个月一次，像什么比武大会之类的。不应该仅仅放一两次活动，这样做性价比很低。</p>
    <p class="idt">（3）西天取经</p>
    <p class="idt">也是比较复杂的玩法了，涉及PVE和PVP，类似燃烧的远征。玩法本身设计得很“重”，但其实玩起来很单调，不好玩，只是为了刷里面的奖励，很耗时间和精力。这也是被玩家吐槽得最多的地方，后面做了很多迭代优化，主要都是减轻玩法对玩家的负担。</p>
    <p class="idt">（4）客户端工作</p>
    <p class="idt">这方面没有做什么大的制作，都是些比较小的，总量比去年要多。能分担一部分工作，对自己起到一定的锻炼作用，但效率并不高。毕竟做服务端编程的时间比较多，客户端的开发环境始终不太习惯。当然也有一个原因，客户端的代码质量问题较大，有些实在没法看，硬着头皮看好几遍才能看懂。关于代码质量的问题，后面再重点说说。</p>
    <p class="idt">（5）领土争夺</p>
    <p class="idt">目前为止最复杂的单一玩法，这个玩法最大的难点在于跨服、实时还有集中。跨服的东西本身做挺多，但由于中心服是单点，加上RFC的一些缺陷，逻辑上需要考虑的东西很多，比如容错、性能等。而实时的需求，实际上加重了这方面的设计负担，因为它要求更多的状态同步。但这两个也不是最严重的问题，最严重的是，这还是一个集中式的玩法。迷你的架构其实最怕这种集中式的玩法，因为所有玩家都在这个时间发战斗请求，而我们的战斗是绝大部分服务器卡的原因所在。后来实在没办法，除了战斗加锁外，只能实施战场分批开，避免所有战斗都集中在某个时间段进行。后面再详细说说架构的事情。</p>
    <p class="idt">（6）其余制作，维护</p>
    <p class="idt">这块工作其实挺多的，是块长尾，不一一列举了。</p>
    <p class="idt">RTS方面，大概在8月中开始过渡到这边的工作，分立项前和立项后两个阶段。</p>
    <p class="idt">立项前主要是纯客户端的工作，包括相关工具的学习（NeoX引擎、cocosui编辑器）。由于客户端的经验比较少，尤其是3D游戏，所以主要帮忙做一些UI或者逻辑的修改。这样能保证产出，让客户端核心可以专心做更重要的工作。</p>
    <p class="idt">立项后主要是服务端方面的前期工作，包括：</p>
    <p class="idt">（1）引擎相关</p>
    <p class="idt"> 这个新引擎没有文档，哪怕简单的API文档也没有，所以只能结合KM上的文章通读源码，还是比较花时间的。MongoDB是开源数据库，经过业界很多项目的验证，公司不少项目也在使用，所以这块学习资料也是比较充足的，互联网的还有KM上的，内容很多，所以学习起来相对容易一些。</p>
    <p class="idt">（2）运行环境、基础架构</p>
    <p class="idt">写好配置、运维脚本，让引擎跑起来。根据我们项目特性，做一些相关修改和更新，如MongoDB分表保存，pymongo新版本替换。把引擎的客户端模块集成到我们项目的客户端逻辑，调通双方的通信。</p>
    <p class="idt">（3）目录、模块</p>
    <p class="idt">定好基本的目录结构，做好基础的逻辑模块的划分，约定好与客户端共用的模块及通信接口方式。</p>
    <p class="idt">（4）基础功能</p>
    <p class="idt">主要是网络通信模块，登陆，选择、创建角色，玩家数据，进入房间PVP简单匹配，服务器列表等。</p>
    <p class="idt">（5）周边工具</p>
    <p class="idt">行为树工具重构改造，引入到我们项目。客户端的一些第三方模块，如mapper、math3d集成到服务端引擎。</p>
    <p class="idt">（6）项目规范、说明文档</p>
    <p class="idt">包括KM上的文章，还有项目里的readme.txt等。</p>
    <p class="idt">由于这套服务端框架是第一次接触，没有经验，没有文档，所以很多工作其实都是摸索中进行，经常需要写demo去验证想法。另外新引擎其实也是有很多坑的，它有比旧引擎好的地方，但并不是所有东西都是想象中的那么美好。搞这些底层相关工作本身也比较花时间，因为途中会遇到各种意想不到的坑，产出没法得到很好的保证。这个过程踩过的坑，解决了的问题，我会把经验积累下来，希望能为后面的人提高产出。目前最主要的事情是调通了客户端到服务端，及服务端到数据库的通信框架，下一步是把战斗做成联网的。</p>
    <p class="idt">按我初步的设想，这个战斗是直接做到引擎的游戏进程里面，因为这样足够简单，可以快速的实现。但这样是有一个问题的，就是战斗协议，都经过了网关（网关进程）的分发，这里可能会产生性能问题。后面估计还是需要写一个独立的战斗服进程，每个进程可以跑多个战斗，进程数大致等于CPU核数，协议可以换成包体更优秀的UDP，序列化和反序列化换成C++来实现等，这样最终应该是比较靠谱的方案。等战斗迁移完成，看到联机效果了，我会着手开始实现战斗服进程这一块功能。不管怎样，work first optimize later，先做出来再说，优化的方法总是有的。</p>
    <p class="idt">下面是关于产品、代码质量、服务端技术的一些思考。</p>
    <p class="idt">·产品</p>
    <p class="idt">RTS这种游戏，我觉得在移动设备上是挺难做的，主要是客观因素的制约。</p>
    <p class="idt">从技术上来说，游戏类型复杂，非常重度，实现起来难度高；实时PVP，需要解决网络同步问题，移动设备网络对这方面要求更高；战斗单位多，意味着更多的单位计算、AI和渲染，还有更多的状态同步；整个团队其实没怎么做过这种RTS类的游戏，很多技术、工具需要摸索，也一定会遇到很多技术上的问题，需要攻克。</p>
    <p class="idt">从设计上来说，存在各种设计和硬件的矛盾冲突。比如手机屏幕小，而游戏需要显示很多单位；触摸屏设备交互方式有限，而游戏需要非常复杂的操作等等。这些问题，如果不做好取舍，很容易陷入设计的死胡同。比如之前”双指拖屏“的问题，如果demo的时候侥幸过了，后面功能做下去，只要设备支持，肯定会出现”三指拖屏“甚至”四指拖屏”。又比如之前曾经提到过的，做点击和拖动两套兼容的交互方案，可以让玩家自由去选择，或者新手阶段先教点击，后面玩家留下来了，强行转拖动。做这个兼容，显然不如把其中一种操作做到极致，让产品能提早上线，来得更重要，更不说后面的维护成本。</p>
    <p class="idt">堆叠功能其实并不难，难的是站在一个全局的角度去做权衡，做取舍。哪些功能在现有的条件下，可以做到极致的体验；哪些功能则是做了反而会影响核心体验，需要舍弃。比如像COC，整个战斗，核心操作就只有放兵。肯定有玩家喜欢自己操作士兵怎样攻击目标，但是他不提供这个功能，这是一个非常创新的取舍。再举一个例子，硅谷的公司，即便是那种创业的小公司，一开始做产品就是做Internationalization的，而很少去做Localization的工作。比如说一个交互，他们只会做一种，不会说为了中国用户做一种，为了美国的用户又做一种，即便中国的用户和美国的用户在习惯上文化上有各种各样的差异。这样有利于他们的产品在本土上线后，能够在不到半年的时间迅速往全球推广。做Localization短时间内能在某个局部的地区提高收益，但是从全局的角度看，增加了维护成本，反而得不偿失。这样的思路其实也是一种取舍，专注核心功能，少做兼容，快速上线，不断迭代，值得我们去学习。</p>
    <p class="idt">·代码质量</p>
    <p class="idt">对于产品是否成功，代码质量并不是一个决定性因素。也确实有成功的产品，里面的代码写得很糟糕。但提高代码质量，对于团队的开发效率，维护成本，是有好处的。团队合作编程避免不了阅读和维护别人的代码，阅读糟糕的代码不但影响工作效率，浪费大量工时，还非常影响心情。相反，统一的风格，良好的命名规范，则能让大家阅读别人的代码就像阅读自己写的一样，降低心智负担，提高效率。目前我们项目的代码规范是尽量往业界靠拢，术语的选定尽量简单易记，原则是简单，统一。避免过于严苛，因为那样反而会影响开发效率。规范的问题在一开始的时候保持开放，让大家都参与并且达成一致认识，之后严格执行，这样早期就能建立起好的代码模板。后面招新人，团队扩大之后，因为加入新项目一开始写代码都是模仿的，代码质量也能有所保证。</p>
    <p class="idt">·服务端技术</p>
    <p class="idt">这部分从迷你说起。作为公司试水手游领域的产品，迷你的最主要任务是检验市场。没有人能预测什么项目能成功，什么不能，我们能做的是不断地根据市场变化来调整方向，尽快让产品上线，根据市场作出反应，不断做迭代优化。而技术选型则需要在立项之初拍板，中途变更的成本恐怕所有技术团队都承担不起。在这两个大前提下，选择现在这套mudos框架是非常正确的。因为无论从业务类型、技术成熟度、团队技术经验这几个因素来说，mudos都是在有限资源下能让产品快速上线的最稳妥选择。最终迷你也因此能够以公司首款手游推出，吃了第一波最大的资源，获得不错的成绩。</p>
    <p class="idt"> 但是，服务端的东西就是这样，做100个人用的系统，和做100万人用的系统，是完全不一样的。迷你上线第一个月，服务端架构的问题就充分暴露出来，玩家纷纷表示服务器非常的卡。我那时候做了一些优化，比如战斗加CD，把集中的逻辑打散，情况稍微缓解。这些优化，很多只是规避了问题，并没有解决。因为迷你的架构是这样，逻辑和数据库绑死了，一个服务器的数据只能跑在某一台机器上，它没办法做伸缩。也就是我想让更多的CPU给某些繁忙的服务器做运算，办不到，或者说很困难，很曲折。</p>
    <p class="idt">而当时观察，最卡的服务器，在线玩家也就1000人。为什么同样的引擎，梦幻能撑1万8，而我们只能到1000？原因很简单，因为梦幻的游戏类型和我们有本质的不同。梦幻是回合制的mmo，一个战斗过程进行得非常缓慢，所以计算量得以均匀分摊到所有时间点上。迷你则不一样，整个战斗需要在一瞬间计算完成，典型的CPU密集型业务。假如某个时刻有100个玩家点战斗，那就是有100个CPU密集运算请求，而逻辑又是单线程，可想而知有多卡。</p>
    <p class="idt">回到我们项目，像RTS这种游戏类型，如果我们继续用纯迷你的框架去做，肯定是不行的。必须额外写一个战斗服务器，让这些CPU密集型的运算分出去，做到可伸缩。</p>
    <p class="idt">新引擎其实在可伸缩这块做得更彻底，因为它是逻辑和数据分离的。整个框架，是一个分布式架构，连数据库这个所谓的“单点”，其实它内部也是分布式的。玩家从数据库load到哪个游戏进程，事先是不知道的，由引擎内部的一些负载均衡策略决定。所以玩家属于哪个服务器，本质只是身上的一个变量，是一种逻辑的概念，而不是原来那种物理的概念了。这样子，理论上只要有足够多的机器，一个服务器的人数是没有上限的，搞世界同服都可以。玩家之间的简单交互，比如聊天，通过网关转发；复杂交互，比如战斗，则先迁移到同一个进程，在进程内对象之间的通信就非常简单了。</p>
    <p class="idt">除了架构，新引擎的另一个优势是脚本语言，它本身是Python写的，维护起来相对简单。可扩展性高，其他很多工具都有Python接口。客户端也是用Python做脚本，这样程序员开发功能就可以两边都做了，减少语言转换带来的负担，提高开发效率。</p>
    <p class="idt">所以抛开最初的学习成本，我们的游戏类型应该说更适合使用新引擎来实现。</p>
    <p class="idt">这一年依然非常感谢每一位一起努力的同事，虽然旧项目在没落，但是新项目在诞生。这是一个从头做起的项目，真正的考验，才刚刚开始。只有坚持下来，才能有所收获。希望明年新产品成功上线，能够写一些东西，和大家分享。</p>
    <br />
    <p class="text_right">2016年1月</p>
    </section>
</div>

<footer><p>busuncle</p></footer>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-37200104-2', 'busuncle.github.io');
  ga('send', 'pageview');

</script>

</body>
</html>
